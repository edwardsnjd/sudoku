// Generated by CoffeeScript 1.7.1
(function() {
  var Grid, RandomMoveStrategy, Solver;

  Grid = (function() {
    var allIndices, indexCollections;

    indexCollections = [];

    allIndices = [];

    function Grid(data) {
      var boxX, boxY, indicesForThisBox, startX, startY, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this.data = data;
      this.order = 3;
      this.dimension = this.order * this.order;
      this.symbols = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      for (x = _i = 0, _ref = this.dimension; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.dimension; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          allIndices.push(this.getCellIndex(x, y));
        }
      }
      for (y = _k = 0, _ref2 = this.dimension; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
        indexCollections.push((function() {
          var _l, _ref3, _results;
          _results = [];
          for (x = _l = 0, _ref3 = this.dimension; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; x = 0 <= _ref3 ? ++_l : --_l) {
            _results.push(this.getCellIndex(x, y));
          }
          return _results;
        }).call(this));
      }
      for (x = _l = 0, _ref3 = this.dimension; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; x = 0 <= _ref3 ? ++_l : --_l) {
        indexCollections.push((function() {
          var _m, _ref4, _results;
          _results = [];
          for (y = _m = 0, _ref4 = this.dimension; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; y = 0 <= _ref4 ? ++_m : --_m) {
            _results.push(this.getCellIndex(x, y));
          }
          return _results;
        }).call(this));
      }
      for (boxX = _m = 0, _ref4 = this.order; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; boxX = 0 <= _ref4 ? ++_m : --_m) {
        for (boxY = _n = 0, _ref5 = this.order; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; boxY = 0 <= _ref5 ? ++_n : --_n) {
          indicesForThisBox = [];
          startX = boxX * this.order;
          startY = boxY * this.order;
          for (x = _o = startX, _ref6 = startX + this.order; startX <= _ref6 ? _o < _ref6 : _o > _ref6; x = startX <= _ref6 ? ++_o : --_o) {
            for (y = _p = startY, _ref7 = startY + this.order; startY <= _ref7 ? _p < _ref7 : _p > _ref7; y = startY <= _ref7 ? ++_p : --_p) {
              indicesForThisBox.push(this.getCellIndex(x, y));
            }
          }
          indexCollections.push(indicesForThisBox);
        }
      }
    }

    Grid.prototype.isValid = function() {
      var indices, indicesWithSymbol, symbol, _i, _j, _len, _len1, _ref;
      _ref = this.symbols;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        symbol = _ref[_i];
        for (_j = 0, _len1 = indexCollections.length; _j < _len1; _j++) {
          indices = indexCollections[_j];
          indicesWithSymbol = this.getIndicesMatchingSymbol(indices, symbol);
          if (indicesWithSymbol.length > 1) {
            return false;
          }
        }
      }
      return true;
    };

    Grid.prototype.isFilled = function() {
      return this.getEmptyCellIndices().length === 0;
    };

    Grid.prototype.getEmptyCellIndices = function() {
      return this.getIndicesMatchingSymbol(allIndices, null);
    };

    Grid.prototype.getIndicesMatchingSymbol = function(indices, symbol) {
      var index;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = indices.length; _i < _len; _i++) {
          index = indices[_i];
          if (this.data[index] === symbol) {
            _results.push(index);
          }
        }
        return _results;
      }).call(this);
    };

    Grid.prototype.getCellIndex = function(x, y) {
      return this.dimension * y + x;
    };

    Grid.prototype.clone = function() {
      return new Grid(this.data.slice());
    };

    return Grid;

  })();

  this.Grid = Grid;

  Solver = (function() {
    function Solver() {
      this.moveStrategy = new RandomMoveStrategy();
    }

    Solver.prototype.solve = function(grid) {
      var move, movesToTry, newGrid, solvedNewGrid, _i, _len;
      if (!grid.isValid()) {
        return null;
      }
      if (grid.isFilled()) {
        return grid;
      }
      movesToTry = this.moveStrategy.getCandidateMoves(grid);
      for (_i = 0, _len = movesToTry.length; _i < _len; _i++) {
        move = movesToTry[_i];
        newGrid = grid.clone();
        newGrid.data[move.index] = move.symbol;
        solvedNewGrid = this.solve(newGrid);
        if (solvedNewGrid != null) {
          return solvedNewGrid;
        }
      }
      return null;
    };

    return Solver;

  })();

  RandomMoveStrategy = (function() {
    function RandomMoveStrategy() {}

    RandomMoveStrategy.prototype.getCandidateMoves = function(grid) {
      var emptyCellIndices, indexToSet, symbol;
      emptyCellIndices = grid.getEmptyCellIndices();
      indexToSet = emptyCellIndices[0];
      return (function() {
        var _i, _len, _ref, _results;
        _ref = grid.symbols;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          symbol = _ref[_i];
          _results.push({
            index: indexToSet,
            symbol: symbol
          });
        }
        return _results;
      })();
    };

    return RandomMoveStrategy;

  })();

  this.Solver = Solver;

  describe("Grid", function() {
    it("should exist", function() {
      return expect(Grid).toBeDefined();
    });
    return describe("isValid", function() {
      it("should exist", function() {
        var grid;
        grid = new Grid(GridData.completeGrid);
        return expect(grid.isValid).toBeDefined();
      });
      it("should return true for complete grids", function() {
        var grid, result;
        grid = new Grid(GridData.completeGrid);
        result = grid.isValid();
        return expect(result).toEqual(true);
      });
      it("should return false for invalid row grids", function() {
        var grid, result;
        grid = new Grid(GridData.invalidRowGrid);
        result = grid.isValid();
        return expect(result).toEqual(false);
      });
      it("should return false for invalid column grids", function() {
        var grid, result;
        grid = new Grid(GridData.invalidColumnGrid);
        result = grid.isValid();
        return expect(result).toEqual(false);
      });
      return it("should return false for invalid cell grids", function() {
        var grid, result;
        grid = new Grid(GridData.invalidCellGrid);
        result = grid.isValid();
        return expect(result).toEqual(false);
      });
    });
  });

  this.GridData = {
    invalidRowGrid: [1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    invalidColumnGrid: [1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    invalidCellGrid: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    completeGrid: [1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 1, 2, 3, 7, 8, 9, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 8, 9, 1, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, 2, 3, 4, 5, 9, 1, 2, 3, 4, 5, 6, 7, 8],
    almostCompleteGrid: [1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 1, 2, 3, 7, 8, 9, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 8, 9, 1, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, 2, 3, 4, 5, 9, 1, 2, 3, 4, 5, 6, 7, null],
    mainlyCompleteGrid: [1, 2, null, 4, 5, 6, 7, null, 9, 4, 5, 6, 7, null, 9, 1, 2, null, 7, 8, 9, 1, 2, 3, null, 5, 6, 2, null, 4, 5, 6, 7, 8, 9, null, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, null, 2, 3, null, 5, 6, null, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, null, 3, 4, null, 9, 1, null, 3, 4, 5, 6, 7, null],
    newspaperGrid: [null, null, null, 4, null, null, 2, 9, null, 4, null, null, null, null, 5, null, 1, null, 5, null, 1, null, 2, null, null, 6, null, null, null, null, null, null, 6, null, null, 3, null, null, null, 5, 4, 8, null, null, null, 8, null, null, 1, null, null, null, null, null, null, 6, null, null, 7, null, 5, null, 9, null, 1, null, 2, null, null, null, null, 8, null, 4, 8, null, null, 3, null, null, null]
  };

  describe("Solver", function() {
    it("should exist", function() {
      return expect(Solver).toBeDefined();
    });
    return describe("solve", function() {
      var solver;
      solver = new Solver();
      it("should exist", function() {
        return expect(solver.solve).toBeDefined();
      });
      it("should return completed grids", function() {
        var result;
        result = solver.solve(new Grid(GridData.completeGrid));
        return expect(result.data).toEqual(GridData.completeGrid);
      });
      it("should return null for invalid grids", function() {
        var result;
        result = solver.solve(new Grid(GridData.invalidRowGrid));
        return expect(result).toBeNull();
      });
      it("should solve final missing cell", function() {
        var result;
        result = solver.solve(new Grid(GridData.almostCompleteGrid));
        return expect(result.data).toEqual(GridData.completeGrid);
      });
      it("should solve mainly complete grid", function() {
        var result;
        result = solver.solve(new Grid(GridData.mainlyCompleteGrid));
        return expect(result.data).toEqual(GridData.completeGrid);
      });
      return xit("should solve newspaper grid", function() {
        var result;
        result = solver.solve(new Grid(GridData.newspaperGrid));
        return expect(result.data).not.toBeNull();
      });
    });
  });

}).call(this);
