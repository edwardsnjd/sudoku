// Generated by CoffeeScript 1.7.1
(function() {
  var Solver;

  Solver = (function() {
    var dimension, symbols;

    function Solver() {}

    dimension = 9;

    symbols = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    Solver.prototype.solve = function(grid) {
      var emptyCellIndices, indexToSolve, newGrid, solvedNewGrid, symbol, _i, _len;
      if (!this.isValid(grid)) {
        return null;
      }
      if (this.isFilled(grid)) {
        return grid;
      }
      emptyCellIndices = this.getEmptyCellIndices(grid);
      indexToSolve = emptyCellIndices[0];
      for (_i = 0, _len = symbols.length; _i < _len; _i++) {
        symbol = symbols[_i];
        newGrid = grid.slice();
        newGrid[indexToSolve] = symbol;
        solvedNewGrid = this.solve(newGrid);
        if (solvedNewGrid != null) {
          return solvedNewGrid;
        }
      }
      return null;
    };

    Solver.prototype.isValid = function(grid) {
      var box, boxCellOffsets, boxStartOffsets, cellOffset, indexCollections, indices, indicesWithSymbol, symbol, x, y, _i, _j, _k, _l, _len, _len1, _m;
      indexCollections = [];
      for (y = _i = 0; 0 <= dimension ? _i < dimension : _i > dimension; y = 0 <= dimension ? ++_i : --_i) {
        indexCollections.push((function() {
          var _j, _results;
          _results = [];
          for (x = _j = 0; 0 <= dimension ? _j < dimension : _j > dimension; x = 0 <= dimension ? ++_j : --_j) {
            _results.push(this.getCellIndex(x, y));
          }
          return _results;
        }).call(this));
      }
      for (x = _j = 0; 0 <= dimension ? _j < dimension : _j > dimension; x = 0 <= dimension ? ++_j : --_j) {
        indexCollections.push((function() {
          var _k, _results;
          _results = [];
          for (y = _k = 0; 0 <= dimension ? _k < dimension : _k > dimension; y = 0 <= dimension ? ++_k : --_k) {
            _results.push(this.getCellIndex(x, y));
          }
          return _results;
        }).call(this));
      }
      boxCellOffsets = [0, 1, 2, 9, 10, 11, 18, 19, 20];
      boxStartOffsets = [0, 3, 6, 27, 30, 33, 54, 57, 60];
      for (box = _k = 0; 0 <= dimension ? _k < dimension : _k > dimension; box = 0 <= dimension ? ++_k : --_k) {
        indexCollections.push((function() {
          var _l, _len, _results;
          _results = [];
          for (_l = 0, _len = boxCellOffsets.length; _l < _len; _l++) {
            cellOffset = boxCellOffsets[_l];
            _results.push(boxStartOffsets[box] + cellOffset);
          }
          return _results;
        })());
      }
      for (_l = 0, _len = symbols.length; _l < _len; _l++) {
        symbol = symbols[_l];
        for (_m = 0, _len1 = indexCollections.length; _m < _len1; _m++) {
          indices = indexCollections[_m];
          indicesWithSymbol = this.getIndicesMatchingSymbol(grid, indices, symbol);
          if (indicesWithSymbol.length > 1) {
            return false;
          }
        }
      }
      return true;
    };

    Solver.prototype.isFilled = function(grid) {
      var emptyCellIndices;
      emptyCellIndices = this.getEmptyCellIndices(grid);
      return emptyCellIndices.length === 0;
    };

    Solver.prototype.getEmptyCellIndices = function(grid) {
      var allIndices, x, y, _i, _j;
      allIndices = [];
      for (x = _i = 0; 0 <= dimension ? _i < dimension : _i > dimension; x = 0 <= dimension ? ++_i : --_i) {
        for (y = _j = 0; 0 <= dimension ? _j < dimension : _j > dimension; y = 0 <= dimension ? ++_j : --_j) {
          allIndices.push(this.getCellIndex(x, y));
        }
      }
      return this.getIndicesMatchingSymbol(grid, allIndices, null);
    };

    Solver.prototype.getIndicesMatchingSymbol = function(grid, indices, symbol) {
      var index;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = indices.length; _i < _len; _i++) {
          index = indices[_i];
          if (grid[index] === symbol) {
            _results.push(index);
          }
        }
        return _results;
      })();
    };

    Solver.prototype.getCellIndex = function(x, y) {
      return dimension * y + x;
    };

    return Solver;

  })();

  this.Solver = Solver;

  describe("Solver", function() {
    var almostCompleteGrid, completeGrid, invalidGrid, invalidGrid2, mainlyCompleteGrid, newspaperGrid;
    invalidGrid = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    invalidGrid2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    completeGrid = [1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 1, 2, 3, 7, 8, 9, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 8, 9, 1, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, 2, 3, 4, 5, 9, 1, 2, 3, 4, 5, 6, 7, 8];
    almostCompleteGrid = [1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 1, 2, 3, 7, 8, 9, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 8, 9, 1, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, 2, 3, 4, 5, 9, 1, 2, 3, 4, 5, 6, 7, null];
    mainlyCompleteGrid = [1, 2, null, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9, 1, 2, 3, 7, 8, 9, 1, 2, 3, null, 5, 6, 2, null, 4, 5, 6, 7, 8, 9, 1, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 1, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 9, 1, 2, 6, 7, 8, 9, 1, null, 3, 4, 5, 9, 1, null, 3, 4, 5, 6, 7, null];
    newspaperGrid = [null, null, null, 4, null, null, 2, 9, null, 4, null, null, null, null, 5, null, 1, null, 5, null, 1, null, 2, null, null, 6, null, null, null, null, null, null, 6, null, null, 3, null, null, null, 5, 4, 8, null, null, null, 8, null, null, 1, null, null, null, null, null, null, 6, null, null, 7, null, 5, null, 9, null, 1, null, 2, null, null, null, null, 8, null, 4, 8, null, null, 3, null, null, null];
    it("should exist", function() {
      return expect(Solver).toBeDefined();
    });
    describe("isValid", function() {
      var solver;
      solver = new Solver();
      it("should exist", function() {
        return expect(solver.isValid).toBeDefined();
      });
      it("should return true for complete grids", function() {
        var result;
        result = solver.isValid(completeGrid);
        return expect(result).toEqual(true);
      });
      return it("should return false for invalid grids", function() {
        var result1, result2;
        result1 = solver.isValid(invalidGrid);
        result2 = solver.isValid(invalidGrid2);
        expect(result1).toEqual(false);
        return expect(result2).toEqual(false);
      });
    });
    return describe("solve", function() {
      var solver;
      solver = new Solver();
      it("should exist", function() {
        return expect(solver.solve).toBeDefined();
      });
      it("should return completed grids", function() {
        var result;
        result = solver.solve(completeGrid);
        return expect(result).toEqual(completeGrid);
      });
      it("should return null for invalid grids", function() {
        var result;
        result = solver.solve(invalidGrid);
        return expect(result).toBeNull();
      });
      it("should solve final missing cell", function() {
        var result;
        result = solver.solve(almostCompleteGrid);
        return expect(result).toEqual(completeGrid);
      });
      it("should solve mainly complete grid", function() {
        var result;
        result = solver.solve(mainlyCompleteGrid);
        return expect(result).toEqual(completeGrid);
      });
      return it("should solve newspaper grid", function() {
        var result;
        result = solver.solve(newspaperGrid);
        return expect(result).not.toBeNull();
      });
    });
  });

}).call(this);
